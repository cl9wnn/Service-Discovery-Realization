# Service-Discovery-Realization

**Service Disccovery (SD)** - это механизм, который позволяет сервисам в распределенной системе динамически находить друг друга без жесткой привязки к IP-адресам.

Service Discovery в условиях **динамически масштабируемой среды** обеспечивает автоматическое отслеживание доступности, местоположения и состояния сервисов, что позволяет им находить друг друга без необходимости фиксировать IP-адреса.

Это особенно важно для динамического горизонтального масштабирования, где сервисы могут быстро добавляться или удаляться из-за изменений нагрузки.
</br></br>


## Зачем нужен?

В распределенной системе каждый сервис может иметь несколько экземпляров, запущенных на разных узлах, в разных кластерах или даже в разных регионах. 

Чтобы эффективно маршрутизировать запросы между этими экземплярами, система должна иметь возможность постоянно обновлять информацию о том, какие экземпляры доступны, их IP-адреса и порты. Здесь и приходит на помощь Service Discovery, играя центральную роль в **поддержании актуальности данных о сервисах в реальном времени**.


**Основными задачами** SD является:
+ Автоматизация маршрутизации запросов
+ Мониторинг состояния сервисов
+ Актуализация данных для балансировки нагрузки
+ Облегчение конфигурации
</br><br>

## Какие проблемы решает?


По сравнению с **монолитной** архитектурой, где сервер имеет фиксированный IP,  в **MSA** существует ряд сложностей:
+ Сервисы запускаются **динамически**
+ Экземпляры сервисов имеют динамически назначаемые IP адреса
+ Пул сервисов может динамически меняться из-за горизонтального масштабирования
+ Нужна балансировка нагрузки между сервисами

Все это находится под контролем Service Discovery, который разрешает все эти проблемы.
</br><br>

## Типы Service Discovery 

1. **Client‑Side Discovery Pattern**

Клиент отвечает за определение **сетевых местоположений** доступных экземпляров службы и балансировку нагрузки запросов между ними. 

Клиент запрашивает **реестр служб**, который представляет собой базу данных доступных экземпляров службы. Затем клиент использует алгоритм балансировки нагрузки для выбора одного из доступных экземпляров службы и отправляет запрос.

Сетевое расположение (IP адрес + порт) экземпляра сервиса добавляется и удаляется в реестр служб при регистрации и удалении сервиса. Также с помощью механизма проверки работоспособности происходит их обновление в реестре, чтобы данные были актуальны. 

Плюс данного подхода в простоте, но также есть существенный недостаток, заключающийся в том, что он тесно связывает клиента с реестром служб.


2. **Server-Side Discovery Pattern**

Клиент отправляет запрос в службу через балансировщик нагрузки. Балансировщик нагрузки запрашивает реестр и направляет каждый запрос в доступный экземпляр нужной службы. 

Как и в случае с Discovery на стороне клиента, экземпляры служб регистрируются и удаляются из реестра служб.

Одним из главных преимуществ этого шаблона является то, что детали обнаружения скрыты от клиента благодаря балансировщику (часто выступает прокси-сервер). Минусами является дополнительная точка отказа и задержки из-за промежуточного слоя.
</br><br>

## Архитектурные подходы в реализации

Существует несколько архитектурных подходов к реализации Service Discovery, которые могут быть использованы в зависимости от требований к масштабируемости и отказоустойчивости системы. К основным относятся:

1. **Централизованный Service Registry**

Централизованный подход, при котором все сервисы регистрируются в одном реестре при запуске (Consul, Eureka, Etcd). Централизованный реестр облегчает управление и контроль, но также создает потенциальную точку отказа, если сам реестр выйдет из строя.

2. **Децентрализованное обнаружение (DNS, Peer-to-Peer)**

Децентализованный подход предполагает, что каждый сервис несет ответственность за процесс обнаружения других. Используются такие протоколы, как **DNS** или **Peer-to-Peer** для распространения информации о сервисах. Не требуется Service Registry.

3. **Service Mesh**

Вся логика Service Discovery передаётся прокси (**sidecar**), который работает рядом с каждым сервисом. Клиент не ищет сервисы сам — этим занимается Service Mesh.
</br><br>

## Популярные инструменты

На сегодняшний день **Service Discovery** активно используется в микросервисах и распределенных системах. Часто используемыми инструментами являются:
+ Consul
+ Eureka
+ ZooKeeper
+ Etcd
+ Kubernetes

# Микросервисная система

Проект состоит из трех основных компонентов:
1. **ServiceDiscovery** - сервис регистрации и обнаружения
2. **ApiGateway** - API-шлюз для маршрутизации запросов
3. **TestApp** - тестовое клиентское приложение

## Порядок запуска (локально через IDE)

⚠️ **Важно соблюдать последовательность!**

1. **Запустите ServiceDiscovery** - 5102 порт
   Дождитесь полной инициализации

2. **Запустите ApiGateway** - 5100 порт 

3. **Только после этого запускайте TestApp**  
   Тестовое приложение сможет работать только после полной загрузки первых двух сервисов 

Для теста можно сделать GET запрос http://localhost:5102/weatherforecast/health, т.е. на ApiGateway
